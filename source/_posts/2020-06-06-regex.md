---
layout: post
title: "Nodejs process"
date: 2020-06-05 12:47:24 +0800
tags:
  - 基础知识
---



很棒的regEx总结

https://www.jianshu.com/p/9c4979a3b7e4

# 方括号 []

方括号`[ ]`只能匹配一个字符，称为：字符类 或 字符簇。
 其中连字号`-`在`[ ]`中使用时表示一个字符的范围。

Example：



```json
[a-z]      // 匹配所有的小写字母

[A-Z]      // 匹配所有的大写字母

[a-zA-Z]   // 匹配所有的字母

[0-9]      // 匹配所有的数字

[0-9\.\-]      // 匹配所有的数字、句号、减号

[ \n\f\r\t\v]  // 匹配所有的空白字符(空格、换行符、换页符、回车符、水平制表符、垂直制表符)
```

1. `^`除了表示字符串的开头，还有另外一个含义，即当在一组方括号里使用`^`时，它表示”非”或”排除”的意思，常常用来剔除某个字符。

Example：



```json
[^a-z]       // 匹配除了小写字母以外的所有字符

[^\\\/\^]    // 匹配除了\ / ^之外的所有字符

[^\”\’]      // 匹配除了双引号和单引号之外的所有字符
```

# 限定符 {}
 花括号`{}`跟在字符或字符簇后面，用来确定前面的内容重复出现的次数，称为限定符。
     `{3}`     表示：前面的字符或字符簇只出现3次;
     `{3,}`       表示：前面的字符或字符簇出现3次或更多次;
     `{3,5}`     表示：前面的字符或字符簇出现至少3次，至多5次;
 除了`{}`，还有其他的限定符，如:
 `*`：重复0次或多次，等价于：`{0,}`
 `+`：重复1次或多次，等价于：`{1,}`
 `?`：重复0次或1次，等价于：`{0,1}`
 `|`：指明两项之间的一个选择，要匹配`|`，请使用`\|`

Example：

```cpp
^[0-9]{1,}$           // 匹配所有的正数

^[0-9]+$              // +与{1,}相等，表示前面的内容可以是1个或多个

^\-{0,1}[0-9]{1,}$    // 匹配所有的整数

^\-?[0-9]+$           

^\-{0,1}[0-9]{0,}\.{0,1}[0-9]{0,}$  // 匹配所有小数的正则

^\-?[0-9]{0,}\.?[0-9]{0,}$    // ?与{0,1}相等，表示前面的内容是可选的

^\-?[0-9]*\.?[0-9]*$          // *与{0,}相等，表示前面的内容可以是0个或多个
```

> 如果在限定符`*、+、?、{n}、{n,}、{n,m}`之后再添加一个字符`?`，则表示尽可能少地重复字符`?`之前的限定符的重复次数，这种匹配方式称为懒惰匹配。与之相对应的是贪婪匹配，即仅仅使用单个限定符`*、+、?、{n}、{n,}、{n,m}`的匹配。

# 元字符
 4.1 匹配位置的元字符
    `^`  匹配行的开始位置
    `$`  匹配行的结束位置
    `\b` 匹配单词的开始或结束位置
 4.2 匹配字符的元字符
    `.`  匹配除换行符之外的任意字符
    `\d`    匹配一个数字字符，等价于`[0-9]`
    `\D`    匹配一个非数字字符，等价于`[^0-9]`
    `\w`    匹配任何单词字符(包括字母、数字、下划线)，等价于`[a-zA-Z0-9_]`
    `\W`    匹配任何非单词字符，等价于`[^a-zA-Z0-9_]`
    `\s`      匹配任何空白字符，包括空格、换行符、换页符、回车符、水平制表符、垂直制表符，等价于`[ \n\f\r\t\v]`
    `\S`    匹配任何非空白字符，即不包含空格、换行符、换页符、回车符、水平制表符、垂直制表符，等价于`[^ \n\f\r\t\v]`
    `\b`    匹配一个单词边界，也就是指单词和空格间的位置。 例如：er\b可以匹配”never”中的”er”，但不能匹配”verb”中的”er"
    `\B`    匹配非单词边界。 例如：`er\B`可以匹配”verb”中的”er”，但不能匹配”never”中的”er”

Example：

```ruby
^.{3}$            只能输入长度为3的字符

^[a-zA-Z0-9]+$    只能输入由数字、字母组成的字符串

^\w+$             只能输入由数字、字母、下划线三种单词字符组成的字符串

(\w)\1            匹配两个重叠出现的字符，其中\1表示对所获取匹配的引用。例如： “aabbc11ads”，匹配结果为三组”aa”、“bb”、“11”的match。在第一次匹配过程中，\1就表示了对匹配字符a的引用，因此对连续出现的a匹配成功；若改为(\w)\1\1时，则可匹配连续出现三次的字符，如”aaabccc2sa”中的”aaa”和“ccc”。
```

# 正向与反向预查（匹配）

```bash
"Swift1 Swift2 Swift3Swift4Swift4Swift4"
```

`(Swift4)`       匹配Swift4并获取这一匹配，然后存储供以后使用；

`(Swift4)\1`   匹配Swift4Swift4，其中`\1`即表示使用了存储的匹配(存储的第一个匹配)，相当于匹配两次Swift4；

`(Swift3)(Swift4)\2`      匹配Swift3Swift4Swift4，其中`\2`即表示使用了存储的第二个匹配，即Swift4(当然第一个匹配为：Swift3)；

`(?:Swift3)(Swift4)\1`   匹配Swift3Swift4Swift4，与`(Swift3)(Swift4)\2`相同；
 由于在小括号中使用了`?:`，所以第一个匹配(Swift3)没有被存储，只存储了后面的第二个匹配(Swift4)；
 若写成`(?:Swift3)(Swift4)\2`，则正则表达式错误，因为没有存储第二个匹配；
 其中`?:`的作用是匹配Swift3模式字符串，但不会存储该匹配。

`Swift(?=4)`      匹配右边紧跟着4的Swift；
 其中`(?=)`称为：正向预查匹配，`(?=4)`表示先看看有没有4，如果有，则把4左边的Swift匹配出来；如果没有，则继续向右查看，这个过程就是正向预查匹配。

> `(?=expression)`可理解为：匹配字符串expression前面的位置。

`Swift(?!4)`     匹配右边不跟着4的Swift；
 其中`(?!)`称为：正向预查不匹配，`(?!4)`表示先看看有没有4，如果没有，也即不等于4的情况，则把左边的Swift匹配出来；如果有，则继续向右查看，这个过程就是正向预查不匹配。

> `(?!expression)`可理解为：匹配后面不是字符串expression的位置。

`(?<=4)Swift`    匹配左边紧跟着4的Swift，即第五个Swift单词，索引为26到30的字符；
 其中`(?<=)`称为：反向预查匹配，`(?<=4)`表示先看看有没有4，如果有，则把4右边的Swift匹配出来；如果没有，则继续向右查看，这个过程就是反向预查匹配。

> `(?<=expression)`可理解为：匹配字符串expression后面的位置。

`(?<!4)Swift`    匹配左边不跟着4的Swift，即第1、2、3、4、6个Swift单词；
 其中`(?<!)`称为：反向预查不匹配，`(?<!4)`表示先看看有没有4，如果没有，也即不等于4的情况，则把右边的Swift匹配出来；如果有，则继续向右查看，这个过程就是反向预查不匹配。

> `(?<!expression)`可理解为：匹配前面不是字符串expression的位置。

# 其他例子

例子1：强密码 (必须包含数字、小写字母和大写字母三种字符，即这三种字符的组合，且不能使用特殊字符，长度在8-16之间)。

```ruby
^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,16}$
```

例子2：强密码 (必须包含数字和字母两种字符，即数字和字母的组合，且不能使用特殊字符，长度在8-16之间)。



```ruby
^(?=.*[0-9])(?=.*[a-zA-Z])[0-9a-zA-Z]{8,16}$
```

例子3：强密码 (必须包含数字、小写字母、大写字母和特殊字符四种字符，即这四种字符的组合，其中特殊字符为除数字、小写字母、大写字母以外的其他字符，长度在8-16之间)。



```ruby
^(?:(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[^0-9a-zA-Z])).{8,16}$
```

例子4：匹配以两个相同字母结尾的单词，如：zoo、success、all等。



```css
\b[a-zA-Z]*([a-zA-Z])\1\b
```

例子5：金额校验，精确到2位小数。



```ruby
^[0-9]+(.[0-9]{2})?$
```

例子6：金额校验，最多保留2位小数，金额范围：0.01-10000.00。



```ruby
^((0\.\d?[1-9])|(0\.[1-9]0)|([1-9]\d{0,3}(\.\d{1,2})?)|(10000(\.0{1,2})?))$
```

正则表达式解释：
 `(0\.\d?[1-9])`            匹配：0.01~0.09 / 0.1~0.9 / 0.11~0.99
 `(0\.[1-9]0)`             匹配：0.10 / 0.20 / 0.30 / 0.40 / 0.50 / 0.60 / 0.70 / 0.80 / 0.90
 `([1-9]\d{0,3}(\.\d{1,2})?)` 匹配：1.00~9999.99
 `(10000(\.0{1,2})?)`        匹配：10000 或 10000.0 或 10000.00

例子7：正整数中剔除`0、1、2、8、9、10`。



```ruby
^(\d{3,})|(1[1-9])|([2-9]\d)|([34567]{1})$
```

正则表达式解释：
 `(\d{3,})`    匹配：3位及以上数字
 `(1[1-9])`    匹配：以1开头的2位数
 `([2-9]\d)`   匹配：非1开头的2位数
 `([34567]{1})` 匹配：除0、1、2、8、9之外的1位数



